title: 对象入门
id: 186
categories:
  - Java
date: 2015-05-12 14:31:01
tags:
  - OOP
---

OOP（Object-oriented programming）

1，抽象的进步

所有的编程语言的最终目的都是提供一种“抽象”方法。汇编语言是对基础机器的少量抽象，后来许多“命令式”语言（FORTRAN，BASIC，C）是对汇编语言的抽象。与汇编语言相比，这些语言已有了长足的进步，但它们的抽象原理依然要求我们着重考虑计算机的结构，而非考虑问题本身的结构。

我们将问题空间的元素以及它们在方案空间的表示物成为“对象”（Object）。SmallTalk的五大特征，这是第一种成功的面相对象的程序设计语言，也是Java语言的基础：

1.  所有的东西都是对象。对象可以想象成一种新型的变量。
2.  程序是一大堆对象的集合。通过消息传递，个对象知道自己该做些什么。为了面向对象发出请求，需向那个对象发送一条消息。
3.  每个对象都有自己的存储空间，可容纳其他对象。或者说通过封装现有对象可制作出新型对象。
4.  每个对象都有一种类型。每个对象都是某一个类的一个实例，其中Class 和 Type 是同义词。一个类的重要特征是“能够将什么消息发送给它”。
5.  同一类的所有对象能够接受相同的信息。对象的“可替代性”
2，对象的接口

我们向对象发出的请求是通过它的的接口定义的，对象的类型和类则规定了它的接口形式。“类型”和“接口”的等价或对应关系是面向对象程序设计的基础。

3，实现方案的隐藏

客户程序员：收集一个充斥着各种类的编程工具箱，以便能够快速的开发符合自己要求的东西。

类创建者：从头构建一个类，只向客户程序员开放有必要开放的东西（接口），其他所有细节都隐藏起来。

“接口”（Interface）规定了可对一个特定的对象发出哪些请求。然而，必须在某个地方存放着一些代码以便满足这些请求。这些代码以及哪些隐藏起来的数据叫做“隐藏的实现”。

若是任何人都能够使用一个类的所有成员，那么客户程序员可对那个类做任何事情，没有办法强制他们遵守任何约束。有两方面的原因促使我们控制成员的访问。

防止程序员接触他们不该接触的东西，通常是内部数据类型的设计思想。

允许库设计人员修改内部结构，不用担心它会对客户程序员造成什么影响。接口与实现方法早已分开，并分受到保护，用户只需要重新连接一下就好。

Java采用三个显示（明确）关键字以及一个隐式（暗示）关键字来设置类边界：public, private, protected以及暗示性的friendly。若没有明确指定其他关键字，则默认为后者。这些关键字的使用和含义相当直观，它们决定了谁能够使用后续的定义内容。“public”意味着后续的定义任何人均可使用。“private”意味着除了自己、类型创建者以及那个类型的内部函数成员，其他任何人都不能访问后续的定义信息。private在你与客户程序员之间竖起了一堵墙。若有人想访问私有变量成员，就会得到一个编译错误。“friendly”涉及“包装”或“封装”的概念，若某样东西是友好的，意味着它只能在这个包装范围内使用（包装访问）。“protected”与“private”相似，只是一个继承的类可访问受保护的成员，但不能访问私有成员

4，方案的重复使用

代码或设计方案的重复使用是面向对象程序设计提供的最伟大的一种杠杆。

在现有类的基础上组织一个新类----组织。新类的成员对象通常设为“私有”，使用这个类的客户程序员不能访问它们，这样我们可以不干扰客户代码的前提下，从容的修改那些成员。

由于继承的重要性，所以在面向对象的程序设计中，它通常被重点强调。“继承应当随处可见”，沿用这种思想的设计将是非常笨拙的，会大大增加程序的复杂程度。相反，新建类的时候，首先考虑“组织”对象，这样做显得更加简单和灵活。

5，继承：重新使用接口

继承不完全等同于克隆。若原始类（基础类，父类，超类）发生变化，修改过的“克隆类”（继承类或子类）也会反映这些变化。通过extends关键字来实现。

使用继承时，相当于创建了一个新类。这个新类不仅包含了现有类型的所有成员（尽管private 成员被隐藏 起来，且不能访问），但更重要的是，它复制了基础类的接口。

5.1 改善基础类

尽管extends 关键字暗示着我们要为接口“扩展”新功能，但实情并非肯定如此。为区分我们的新类，第二 个办法是改变基础类一个现有函数的行为。我们将其称作“改善”那个函数。 为改善一个函数，只需为衍生类的函数建立一个新定义即可。我们的目标是：“尽管使用的函数接口未变， 但它的新版本具有不同的表现”。

5.2 等价于类似的关系

我们通常认为基础类和衍生类之间存在一种“等价”关系——因为我们可以理直气壮地说：“圆 就是一种几何形状”。

但在许多时候，我们必须为衍生类型加入新的接口元素。所以不仅扩展了接口，也创建了一种新类型。这种 新类型仍可替换成基础类型，但这种替换并不是完美的，因为不可在基础类里访问新函数。我们将其称作 “类似”关系；新类型拥有旧类型的接口，但也包含了其他函数，所以不能说它们是完全等价的。

6，多形对象的互换作用

通常，继承最终以创建一系列类收场，所有类都建立在统一的接口基础之上。

我们将这种把衍生类当做它的基础类型处理的过程叫做Upcasting。其中cast是指根据一个想成的模型创建；而Up表明继承的方向是从上面来的。

上溯造型的方法用来避免去调查准确类型的一个好办法。

6.1 动态绑定

将一条消息发送给对象时，如果并不知道对方的具体类型是什么，但采取的行动同样是正确的，这种情况就叫做“多形性”。对面向对象的程序设计语言来说，它们用以实现多形性的方法叫做“动态绑定”。

6.2 抽象的基础类和接口

我们经常希望基础类能够给自己的衍生类提供一个接口。使用“abstract”关键字，如果有人试图创建抽象类的一个对象，编译器会阻止他们。可以用“abstract”关键字描述一个尚未实现的方法，作为“根”使用。继承抽象类的衍生类必须实现abstract方法，不然也会变成抽象类。通过创建一个抽象方法，我们可以将一个方法置入接口中，不必再为那个方法提供可能毫无意义的主题代码。

Interface（接口）关键字将抽象类的概念更延伸了一步，它完全禁止了所有的函数定义。“接口”是一种相当有效和常用的工具，另外如果自己愿意，可以将多个接口合并成在一起。

7，对象的创建和存在的时间

对象的创建及破坏方式，对象需要的数据在哪？如何控制对象的“存在时间”呢？

C++ 认为程序的执行效率是最重要的一个问题，所以它允许程序员做出选择。为获得最快的运行速度，存储以及存在时间可在编写程序时指定，只需将对象放置在堆栈或者静态存储区域即可。这样便为存储空间的分配和释放提供了一个优先级。某种情况下这种优先级是非常有价值的。

在一个内存池中动态的创建对象，该内存池也叫“堆”或“内存堆”。若采用这种方式，除非进入运行期，否则根本不知道到底需要多少个对象，也不知道它们的存在时间有多长，以及准确的类型是什么？

存储空间的管理是在运行期动态进行的，所以在内存堆里分配存储空间的时间比在堆栈里创建的时间长的多。

C++允许我们决定是在写程序时创建对象，还是在运行时创建对象，这种控制方法更加灵活。对象的生存时间“Lifttime”。若在堆栈或者静态存储空间里创建一个对象，编译器会判断对象的持续时间有多长，会到时自动“破坏”或者“清除”它。程序员可用两种方式破会一个对象：用程序话方法来决定何时破坏对象，或者利用由运行环境提供的一种“垃圾收集器”的特性，自动寻找那些不再使用的对象，并将其清除。

7.1 集合与继承器

集，队列，散列表，数，堆栈等等。所有的集合都提供了相应的读写功能。Push，Add功能。

继承器（Iterator），它属于一种对象，负责选择集合内的元素，并把它们提供给继承器的用户。最早的标准继承器（Enumeration），java1.2中添加Iteration。

根据具体的需求选择集合类型。

7.2 单根结构

在Java中所有类都继承于Object类，单根结构有很多优点：

*   都有相同的类型
*   不会判断不出一个对象的类型
*   方便省事，适用于新手，我们可以更方便的实现一个垃圾收集器
7.3 集合库与方便使用集合

下塑造性与模板/通用性

Downcasting。从一个集合中提取对象句柄时，必须用某些方法记住它，以保证下塑造性的正确进行。利用参数化类型，定制集合。

7.4 对象清除

在Java中，垃圾收集器在设计时已考虑到了内存的释放问题。垃圾收集器“知道”一个对象在什么时候不再使用，让后会自动释放那个对象占据的内存空间，采用这种方式，另外加上所有对象都从单根Object继承的事实，而且由于我们只能在内存堆中以一种方式创建对象，所以Java的编程要比C++ 的编程简单得多。

垃圾收集器对效率的影响

Java是在运行时动态的创建对象，C++则是在堆栈中创建对象。在堆栈中创建对象是为对象分配存储空间最有效的一种方式，也是释放那些空间最有效的一种方式。在内存堆（Heap）中创建对象可能要付出昂贵的代价，如果总是从同一基础类继承，并使用所有函数调用都具有“同质多形”特征，那么也不可避免地需要付出一定的代价。

8 违例控制：解决错误

“违例控制”是将错误控制方案内置到程序设计语言中，有时甚至内建到操作系统内。“Exception”特殊的对象，从产生错误的地方抛出。Java中的为例控制模块从一开始就封装好的，所以必须使用它。

9 多线程

在计算机编程中，一个最基本的概念就是同时对多个任务加以控制。最早是“中断服务例程”，主进程暂时通过硬件级的中断实现的。很难移植，造成了另一类的代价高昂的问题。中断对于那些实时性很强的任务来说是必要的。但还存在其他许多问题，，它们只要求将问题划分进入独立运行的程序片断中，使整个程序快速更迅速地响应用户的请求。在一个程序中，这些独立运行的片断叫做“线程”，利用它编程的概念叫做“多线程处理”。多线程处理一个常见的例子就是用户界面。利用线程，用户可以按下一个按钮，然后程序会立即做出响应，而不是让用户等待程序完成当前任务后再开始响应。最开始，线程只是用于分配单个处理器的处理时间的一种工具。但假如操作系统支持多个处理器，那么每个线程都可以分配给一个不同的处理器，真正进入“并行计算”状态。从程序设计语言的角度看，多线程操作最优价值的特性之一就是程序员不必关系到底使用多少个处理器。程序在逻辑意义上被划分出多个线程。多线程处理的问题：共享资源。一个线程可以将资源锁定，在完成了它的任务后，再解开这个锁，使其他线程可以接着使用同样的资源。

Java的多线程机制已经内建在语言中了，这使一个可能较复杂的问题简单起来。对多线程支持是在对象这一级支持的，所以一个执行线程可以表达为一个对象。Java也提供了有限的资源锁定方案。它能锁定任何对象占用的内存，所以同一时间只能有一个线程使用特定的内存空间。未达到这个目的使用synchronized关键字。其他类型的资源必须有程序员明确锁定，这通常要求程序员创建一个对象，用它代表一种锁，所有线程在访问那个资源是都必须检查这个锁。

10，永久性

创建一个对象后，只要我们需要，它就会一直存在下去。但在程序的运行结束后，对象的生存期也宣告结束。

11，分析与设计

对象是什么？（怎样将自己的项目分割成组件）

它们的接口是什么？（需要将什么消息发给每一个对象）

阶段0 ，计划：决定后面的过程，有阶段性的工作任务。

阶段1，要制作什么：建立需求分析和系统规格，估算出时间。

阶段2，如何创建：必须拿出一套设计方案，并解释其中包含各类对象在外观上是什么样子，以及相互间是如何沟通的。此时用“UML”。

阶段3，开始创建：先拿出一套较为全面的方案，使其尽可能的设想周全。

阶段4，校订：改变。