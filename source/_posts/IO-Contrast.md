title: IO-Contrast
date: 2015-12-03 17:37:25
tags: NIO
---

## 4中I/O对比

### 异步非阻塞I/O
在早期JDK1.4 和 1.5 Update10版本之前，JDK的Selector基于select/poll模型实现，它是基于I/O复用技术的非阻塞I/O，不是异步I/O。在JDK1.5 Update 10 和 Linux core 2.6 以上版本，Sun优化了Selector实现，它在底层使用epoll替换了selector/poll，上层的API没有变化。
由于 JDK1.7 提供的NIO2.0,新增了异步套接字通道，它是真正的异步I/O，在异步I/O操作的时候可以传递信号变量，当操作完成后悔调用相关的方法，异步I/O被称为AIO。
NIO类库支持非阻塞读和写，相比于之前的同步阻塞读和写，它是异步的，因此习惯称NIO为异步非阻塞I/O。

### 多路复用器Selector
JAVA NIO的实现关键是多路复用I/O技术，多路复用的核心就是通过Selector轮询注册在其上Channel，当发现某个或者多个Channel处于就绪状态后，从阻塞状态返回就绪的Channel的选择键集合，进行I/O操作。由于多路复用器是NIO实现非阻塞IO的关键，它又是主要通过Selector实现的。

### 伪异步I/O
伪异步I/O的概念来源于实践，在JDK NIO编程没有流行之前，为了解决Tomcat通信线程同步I/O导致业务线程被挂住的问题，大家想了一个方法：在通信线程和业务线程之间做一个缓冲区，这个缓冲区用于隔离I/O线程和业务线程间的直接访问，这样业务线程就不会被I/O线程阻塞。对于后端业务来说，将消息或者Task放到线程池后就返回了，它不再直接访问I/O线程或进行I/O读写，这样就不会被同步阻塞。类似的设计还包含前端启动一组线程，将接收的客户端封装成Task，放到后端的线程池执行，用于解决一连接一线程的问题。

## 不同I/O模型对比
表 1 几种I/O模型的功能和特性对比
| 模型 | 同步阻塞I/O（BIO） | 伪异步I/O | 非阻塞I/O（NIO） | 异步I/O（AIO）|
| :----- | :---- | :---- | :---- | :---- |
| 客户端个数：I/O线程 | 1：1  | M:N（其中M可以大于N） | M:1（1个I/O线程处理多个客户端连接） | M:0（不需要启动额外线程，被动调用） |
| I/O类型（阻塞） | 阻塞I/O   | 阻塞I/O | 非阻塞I/O | 非阻塞I/O |
| I/O类型（同步） | 同步I/O   | 同步I/O | 同步I/O（I/O多路复用）| 异步I/O |
| API使用难度 | 简单  | 简单 | 非常复杂 | 复杂 |
| 调度难度 | 简单 | 简单 | 复杂 | 复杂|
| 可靠性 | 非常差 | 差 | 高 | 高 |
| 吞吐量 | 低 | 中 | 高 | 高|
